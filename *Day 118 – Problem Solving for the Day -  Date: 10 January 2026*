//Maya and Riya are on a picnic and have found a row of N snack packs. Each snack pack has a tastiness value. They want to collect snacks in a way that maximizes the total tastiness they get together.
There are some rules:
1.Each snack pack can only be taken once.
2.Maya and Riya cannot pick two adjacent snacks 
3.They take turns, starting with Maya, but they aim to maximize the total tastiness combined, not individually.
4.Maya and Riya are careful planners—they know that taking one snack now may block them from taking a tastier one later. They focus on maximizing the total score, not just picking the largest available snack.
Your task is to compute the maximum total tastiness they can collect following these rules.
Input Format
First line: integer N — number of snack packs (1 ≤ N ≤ 1000)
Second line: N space-separated integers T[i] — tastiness of each snack pack (1 ≤ T[i] ≤ 1000)
Output Format
Single integer — the maximum total tastiness Maya and Riya can collect.
Constraints
1 ≤ N ≤ 1000
1 ≤ T[i] ≤ 1000
*Test Case 1:* 
5
3 2 5 10 7
Output :  15
*Test Case 02 :* 
6
1 20 3 4 5 30
Output ; 
54
*Test Case 03 :* 
7
10 1 10 1 10 1 10
Output :  40

import java.util.*;

public class MaxSnackTastiness {

    public static void main(String[] args) {

        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();

        int[] t = new int[n];
        for (int i = 0; i < n; i++) {
            t[i] = sc.nextInt();
        }

        // Edge case
        if (n == 1) {
            System.out.println(t[0]);
            return;
        }

        int[] dp = new int[n];

        dp[0] = t[0];
        dp[1] = Math.max(t[0], t[1]);

        for (int i = 2; i < n; i++) {
            dp[i] = Math.max(dp[i - 1], dp[i - 2] + t[i]);
        }

        System.out.println(dp[n - 1]);
        sc.close();
    }
}
